def run_codegen_argparse(config, shell):
  """
  Generate C++ code for handling of command-line arguments.

  C++ arg parsing libraries are verbose, repetitive and tedious to use. So instead of writing it manually, we generate
  the code from a JSON definition file here. At some point, if we decide it's too complex or otherwise unsuitable, we
  could drop this step and commit the existing generated code to the source control.
  """
  shell(f"""
    python3 "{config.PROJECT_ROOT_DIR}/packages/nextclade_common/scripts/generate_cli.py" \
      --input_json={config.PROJECT_ROOT_DIR}/packages/nextclade_cli/cli.json \
      --output_cpp={config.PROJECT_ROOT_DIR}/packages/nextclade_cli/src/generated/cli.cpp \
      --output_h={config.PROJECT_ROOT_DIR}/packages/nextclade_cli/src/generated/cli.h \
  """, cwd=config.BUILD_DIR)

  # Let's format the generated code to make it more readable
  shell(f"""
    find "{config.PROJECT_ROOT_DIR}/packages/nextclade_cli/src/generated/" \
    -regex '.*\.\(c\|cpp\|h\|hpp\|cc\|cxx\)' \
    -exec clang-format -style=file -i {{}} \; \
  """, cwd=config.BUILD_DIR)


def run_codegen_cainfo(config, shell):
  """
  Generate C++ file with the inlined CA certificate from Curl.
  https://curl.se/docs/caextract.html

  This ensures that networking works regardless of whether CA certificates on a particular the Linux system are
  up-to-date. This is mostly relevant for older versions of   stable distros like Debian and CentOS.
  """
  shell(f"""
    python3 "{config.PROJECT_ROOT_DIR}/packages/nextclade_common/scripts/generate_cainfo_blob.py" \
        --input_pem={config.PROJECT_ROOT_DIR}/packages/nextclade_common/data/cacert.pem \
        --output_h={config.PROJECT_ROOT_DIR}/packages/nextclade_common/src/generated/cainfo.h \
  """, cwd=config.BUILD_DIR)


def run_codegen(config, shell):
  """
  Generates some of the project's autogenerated source code files
  """
  run_codegen_argparse(config, shell)
  run_codegen_cainfo(config, shell)
