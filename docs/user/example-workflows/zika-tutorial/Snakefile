REFERENCE_ACCESSION = config["reference_accession"]
GENES = config["genes"].keys()
ALLOWED_DIVERGENCE = config["allowed_divergence"]
MIN_DATE = config["min_date"]
MIN_LENGTH = config["min_length"]
MAX_SEQS = config["max_seqs"]

FETCH_SEQUENCES = True

if FETCH_SEQUENCES == True:

    include: "rules/fetch_from_ncbi.smk"


# The below is temporary until v3 is released
rule get_nextclade_binary:
    """
    Get the nextclade v3 binary from the nextclade repository
    """
    output:
        "bin/nextclade",
    shell:
        """
        cp ~/code/nextclade/target/release/nextclade bin/nextclade
        """


rule add_reference_to_include:
    """
    Create an include file for augur filter
    """
    input:
        include="resources/include.txt",
    output:
        "results/include.txt",
    shell:
        """
        echo "{REFERENCE_ACCESSION}" >> results/include.txt
        """


rule filter:
    """
    Exclude sequences from before 2015 and subsample to 100 sequences
    """
    input:
        sequences="data/sequences.fasta",
        metadata="data/metadata.tsv",
        include="results/include.txt",
    output:
        filtered_sequences="results/filtered_sequences_raw.fasta",
        filtered_metadata="results/filtered_metadata_raw.tsv",
    params:
        min_date="" if MIN_DATE == "" else "--min-date " + MIN_DATE,
        min_length="" if MIN_LENGTH == "" else "--min-length " + MIN_LENGTH,
        max_seqs=MAX_SEQS,
    shell:
        """
        augur filter \
            --sequences {input.sequences} \
            --metadata {input.metadata} \
            {params.min_length} \
            {params.min_date} \
            --include {input.include} \
            --subsample-max-sequences {params.max_seqs} \
            --output {output.filtered_sequences} \
            --output-metadata {output.filtered_metadata}
        """


"""
Patch GFF and GB:
For GFF:
- For each gene:locus_tag pair:
    1. Nuke the Name attribute
    2. Replace locus_tag=config["gene"]
For GB:
- For each gene:locus_tag pair:
    1. Replace locus_tag=config["gene"]
"""


def sed_patterns_gff(genemap, exclude=[]):
    patterns = []
    for gene, locus_tag in genemap.items():
        patterns.append(f"/locus_tag={locus_tag}/s#Name=[^;]*#Name={gene}#g")
    for pattern in exclude:
        patterns.append(f"/{pattern}/d")
    return "; ".join(patterns)


def sed_patterns_gb(genemap):
    patterns = []
    for gene, locus_tag in genemap.items():
        patterns.append(f's#/locus_tag="{locus_tag}"#/locus_tag="{gene}"#g')
    return "; ".join(patterns)


rule patch_annotations:
    """
    Rename CDS features to make nice display names for Nextclade
    """
    input:
        gff="data/genome_annotation.gff3",
        reference="data/reference.fasta",
    output:
        gff="results/genome_annotation.gff3",
        genbank="results/reference.gb",
    params:
        sed_patterns_gff=lambda w: sed_patterns_gff(
            config["genes"], config.get("exclude_gff", [])
        ),
        sed_patterns_gb=lambda w: sed_patterns_gb(config["genes"]),
    shell:
        """
        sed '{params.sed_patterns_gff}' {input.gff} > {output.gff}
        gff-to-genbank {output.gff} {input.reference} \
        | sed '{params.sed_patterns_gb}' > {output.genbank}
        """


rule align:
    input:
        sequences="results/filtered_sequences_raw.fasta",
        reference="data/reference.fasta",
        annotation="results/genome_annotation.gff3",
        nextclade="bin/nextclade",
    output:
        alignment="results/aligned.fasta",
        tsv="results/nextclade.tsv",
    params:
        translation_template=lambda w: "results/translations/cds_{cds}.translation.fasta",
    shell:
        """
        {input.nextclade} run \
            {input.sequences} \
            --input-ref {input.reference} \
            --input-annotation {input.annotation} \
            --output-translations {params.translation_template} \
            --output-tsv {output.tsv} \
            --output-fasta {output.alignment}
        """


rule get_outliers:
    """
    Automatically identify sequences with >150 substitutions
    (likely to be sequencing errors) and put them in outliers.txt
    """
    input:
        nextclade="results/nextclade.tsv",
    output:
        outliers="results/outliers.txt",
        tmp="tmp/outliers.txt",
    params:
        allowed_divergence=lambda w: ALLOWED_DIVERGENCE,
    shell:
        """
        tsv-filter -H -v --is-numeric totalSubstitutions {input.nextclade} \
        > {output.tmp}
        tsv-filter -H \
            --is-numeric totalSubstitutions \
            --gt totalSubstitutions:{params.allowed_divergence} \
            {input.nextclade} \
        | tail -n +2 >> {output.tmp}
        cat {output.tmp} \
        | tsv-select -H -f seqName \
        | tail -n +2 > {output.outliers}
        """


rule exclude:
    """
    Rule to allow for manual and automatic exclusion of sequences
    without triggering a new subsampling that could
    surface new bad sequences resulting in an infinite loop
    """
    input:
        sequences="results/aligned.fasta",
        metadata="data/metadata.tsv",
        exclude="resources/exclude.txt",
        outliers="results/outliers.txt",
    output:
        filtered_sequences="results/filtered_aligned.fasta",
        filtered_metadata="results/filtered_metadata.tsv",
        strains="results/tree_strains.txt",
    shell:
        """
        augur filter \
            --sequences {input.sequences} \
            --metadata {input.metadata} \
            --exclude {input.exclude} {input.outliers} \
            --output {output.filtered_sequences} \
            --output-metadata {output.filtered_metadata} \
            --output-strains {output.strains}
        """


rule tree:
    input:
        alignment="results/filtered_aligned.fasta",
    output:
        tree="results/tree_raw.nwk",
    shell:
        """
        augur tree \
            --alignment {input.alignment} \
            --output {output.tree} \
        """


rule refine:
    input:
        tree="results/tree_raw.nwk",
        alignment="results/filtered_aligned.fasta",
    output:
        tree="results/tree.nwk",
        node_data="results/branch_lengths.json",
    shell:
        """
        augur refine \
            --tree {input.tree} \
            --alignment {input.alignment} \
            --root {REFERENCE_ACCESSION} \
            --keep-polytomies \
            --divergence-units mutations \
            --output-node-data {output.node_data} \
            --output-tree {output.tree}
        """


rule ancestral:
    input:
        tree="results/tree.nwk",
        alignment="results/filtered_aligned.fasta",
        annotation="results/reference.gb",
    output:
        node_data="results/muts.json",
    params:
        translation_template=r"results/translations/cds_%GENE.translation.fasta",
        output_translation_template=r"results/translations/cds_%GENE.ancestral.fasta",
        genes=" ".join(GENES),
    shell:
        """
        augur ancestral \
            --tree {input.tree} \
            --alignment {input.alignment} \
            --annotation {input.annotation} \
            --genes {params.genes} \
            --translations {params.translation_template} \
            --output-node-data {output.node_data} \
            --output-translations {params.output_translation_template}
        """


rule dummy_clades:
    """
    Nextclade requires clade membership to be specified for each node
    in the tree. This rule creates a dummy clade membership for each node
    """
    input:
        "results/branch_lengths.json",
    output:
        "results/dummy_clades.json",
    shell:
        """
        jq '.nodes |= map_values({{"clade_membership": "dummy"}})' {input} > {output}
        """


rule export:
    input:
        tree="results/tree.nwk",
        metadata="results/filtered_metadata.tsv",
        mutations="results/muts.json",
        branch_lengths="results/branch_lengths.json",
        clades="results/dummy_clades.json",
        auspice_config="resources/auspice_config.json",
    output:
        auspice="results/auspice.json",
    shell:
        """
        augur export v2 \
            --tree {input.tree} \
            --metadata {input.metadata} \
            --auspice-config {input.auspice_config} \
            --node-data {input.mutations} {input.branch_lengths} {input.clades} \
            --output {output.auspice}
        """


rule subsample_example_sequences:
    input:
        all_sequences="data/sequences.fasta",
        tree_strains="results/tree_strains.txt",
    output:
        example_sequences="results/example_sequences.fasta",
    shell:
        """
        # Exclude tree sequences from all sequences
        seqkit grep -v -f {input.tree_strains} {input.all_sequences} \
        | seqkit sample -n 100 -s 42 > {output.example_sequences}
        """


rule assemble_dataset:
    input:
        tree="results/auspice.json",
        reference="data/reference.fasta",
        annotation="results/genome_annotation.gff3",
        sequences="results/example_sequences.fasta",
        pathogen="resources/pathogen.json",
    output:
        tree="dataset/tree.json",
        reference="dataset/reference.fasta",
        annotation="dataset/genome_annotation.gff3",
        sequences="dataset/sequences.fasta",
        pathogen="dataset/pathogen.json",
        dataset_zip="dataset.zip",
    shell:
        """
        cp {input.tree} {output.tree}
        cp {input.reference} {output.reference}
        cp {input.annotation} {output.annotation}
        cp {input.sequences} {output.sequences}
        cp {input.pathogen} {output.pathogen}
        zip -rj dataset.zip  dataset/*
        """


rule test:
    input:
        dataset="dataset.zip",
        bin="bin/nextclade",
        sequences="dataset/sequences.fasta",
    output:
        output=directory("test_out"),
    shell:
        """
        {input.bin} run \
            -D {input.dataset} \
            --output-all {output.output} \
            {input.sequences}
        """
